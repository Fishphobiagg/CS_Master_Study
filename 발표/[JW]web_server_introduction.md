# 웹 서버

작성일시: 2023년 7월 30일 오후 1:26

## Client ↔ Server 개요

![https://gmlwjd9405.github.io/images/web/webserver-vs-was1.png](https://gmlwjd9405.github.io/images/web/webserver-vs-was1.png)

먼저, 정적 페이지와 동적 페이지를 알아보자

### Static Pages

> 바뀌지 않는 페이지
> 

웹 서버는 파일 경로 이름을 받고, 경로와 일치하는 file contents를 반환함

항상 동일한 페이지를 반환함 (image, html, css, js 파일 등)

### Dynamic Pages

> 동적으로 바뀌는 페이지
> 

인자의 내용에 맞게 동적인 contents를 반환함(**비즈니스 로직**)

웹 서버에 의해 실행되는 프로그램을 통해 만들어진 결과물임 (Servlet : was 위에서 돌아가는 자바 프로그램)

### 웹 서버와 WAS의 차이

### 웹 서버 기능

> Http 프로토콜을 기반으로, 클라이언트의 요청을 서비스하는 기능을 담당
> 

요청에 맞게 두가지 기능 중 선택해서 제공해야 한다.

- 정적 컨텐츠 제공
    
    WAS를 거치지 않고 바로 자원 제공
    
- 동적 컨텐츠 제공을 위한 요청 전달
    
    클라이언트 요청을 WAS에 보내고, WAS에서 처리한 결과를 클라이언트에게 전달
    

**웹 서버 종류** : Apache, Nginx, IIS 등

### WAS

Web Application Server의 약자

> DB 조회 및 다양한 로직 처리 요구시 동적인 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버
> 

HTTP를 통해 애플리케이션을 수행해주는 미들웨어다.

**WAS는 웹 컨테이너 혹은 서블릿 컨테이너**라고도 불림

(컨테이너란 JSP, Servlet을 실행시킬 수 있는 소프트웨어. 즉, WAS는 JSP, Servlet 구동 환경을 제공해줌)

**WAS 종류** : Tomcat, JBoss 등

---

**사실 Web Server와 WAS의 경계는 모호하다.**

**하지만 WEB server와 WAS를 구분하는 이유는?**

WAS는 비싸다 → 정적 리소스 파일을 분리하여 부하를 낮춘다.

또한 인간이 개발하는 영역이기에 서버가 죽을 수 있는 가능성이 많다.

또한, 여러 대의 WAS를 연결지어 사용이 가능하다.

웹 서버를 앞 단에 두고, WAS에 오류가 발생하면 사용자가 이용하지 못하게 막아둔 뒤 재시작하여 해결할 수 있다.

자원 이용의 효율성 및 장애 극복, 배포 및 유지 보수의 편의성 때문에 웹 서버와 WAS를 분리해서 사용하는 것이다.

---

### 서버에서 처리해야 하는 일

- ~~서버 TCP/IP 연결 대기, 소켓 연결~~
- ~~HTTP 요청 메시지 파싱, 읽기~~
- ~~POST 방식, URL 인지~~
- ~~Content-type 확인~~
- ~~HTTP 메시지 바디 내용 파싱~~
- ~~저장 프로세스 실행~~
- **비즈니스 로직 실행**
    - **DB 저장 요청**
- ~~HTTP 응담 메시지 생성~~
- ~~TCP/IP에 응답 전달, 소켓 종료~~

서블릿을 지원하는 WAS는 비즈니스 로직을 제외한 다른 일들을 대신 처리해준다.

### 서블릿

톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 한다.

서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리한다.

서블릿 객체는 싱글톤으로 관리한다.

동시 요청을 위한 멀티 쓰레드 처리를 지원한다.

클라이언트에서 요청이 들어오면 → 쓰레드를 할당 → 서블릿 코드 실행

요청이 다수 발생하면?

1. 요청 마다 쓰레드 생성
    
    장점
    
    - 동시 요청 어리
    - 리소스가 허용할 때 까지 처리 가능
    - 하나의 쓰레드가 지연 되어도 나머지 쓰레드는 정상 동작
    
    단점
    
    - 쓰레드 생성 비용은 매우 비싸다
    - 응답 속도 저하 우려
    - 컨텍스트 스위칭 비용
    - 서버가 죽을 수 있다

1. 쓰레드 풀 → 쓰레드 수를 정해놓고 ex)200개 사용 후 반납
- 요청 대기, 거절 설정 가능
- 쓰레드가 미리 생성되어 있어 쓰레드를 생성하고 종료하는 비용을 절약할 수 있다
- 요청이 많이 발생해도 안정적인 처리가 가능하다

### WAS의 멀티쓰레드 지원

개발자는 싱글 쓰레드 프로그래밍을 하듯 편하게 개발 가능하다.

단 싱글톤 객체(서블릿, 스프링 빈)은 조심스럽게 다뤄야 한다.

---

### 서버 동작 개요

> 웹 서버를 WAS 앞에 두고, 필요한 WAS들을 웹 서버에 플러그인 형태로 설정하면 효율적인 분산 처리가 가능함
> 

![https://gmlwjd9405.github.io/images/web/web-service-architecture.png](https://gmlwjd9405.github.io/images/web/web-service-architecture.png)

클라이언트의 요청을 먼저 웹 서버가 받은 다음, WAS에게 보내 관련된 Servlet을 메모리에 올림

WAS는 web.xml을 참조해 해당 Servlet에 대한 스레드를 생성 (스레드 풀 이용)

이때 HttpServletRequest와 HttpServletResponse 객체를 생성해 Servlet에게 전달

> 스레드는 Servlet의 service() 메소드를 호출
> 
> 
> service() 메소드는 요청에 맞게 doGet()이나 doPost() 메소드를 호출
> 

doGet()이나 doPost() 메소드는 인자에 맞게 생성된 적절한 동적 페이지를 Response 객체에 담아 WAS에 전달

WAS는 Response 객체를 HttpResponse 형태로 바꿔 웹 서버로 전달

생성된 스레드 종료하고, HttpServletRequest와 HttpServletResponse 객체 제거

---