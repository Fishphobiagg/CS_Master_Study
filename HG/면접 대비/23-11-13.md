- **단위테스트, TDD란 ?**
  
  단위테스트란 하나의 모듈을 기준으로 진행되는 가장 작은단위의 테스트 입니다.
  
  여기서 모듈은 메서드 단위가 될 수 있고 기능 단위가 될 수 있습니다.
  
  프로젝트에서 테스트 주도 설계를 하진 않았지만 CI/CD 적용과 지라, 슬랙, 노션 등 프로젝트 툴 활용으로 효율적인 프로젝트를 진행했고 개발 기간이 단축되어 2주일이 남았습니다. 따라서 서비스의 안정성을 높이기 위해 예외처리 및 테스크 코드 작성을 진행했고 약 50개의 기능, 메서드의 테스트코드를 작성할 수 있었습니다.
  
  일반적으로 실무에서 의미하는 테스트는 거의 단위 테스트를 의미한다는 글을 보았고 통합 테스트와 비교했을 때 빠르게 문제여부를 확인할 수 있고 코드를 리팩토링 하게되어도 문제가 없는 단위테스트 작성을 진행했습니다.
  
  단위 테스트의 장점은
  
  - 테스팅 시간과 비용 절감
  - 새로운 기능 추가 시 빠르게 테스트 가능한점
  - 리팩토링 시 안정성 확보
  - 코드에 대한 문서 확보
  
  이 정도로 알고 있습니다.
  
  단위테스트 시에 Mokito 라이브러리를 사용했는데 메서드, 기능에 대한 독립적인 테스트에서 발생하는 다른 객체나 모듈과의 의존성 문제를 Mokito를 통해 모킹하여 Stub 하기 위해 사용했습니다.
  
  Stub은 가짜 객체, 모듈을 주입하고 정해진 답변 반환하도록 짜놓는 것입니다.
  
  TDD는 테스트 주도 설계로 실패하는 테스트 코드 작성 → 실제 코드 작성 → 리팩토링 → 테스트 코드 작성
  이 단계를 반복적으로 수행하여 최종적으로 테스트를 통과하는 코드를 추가하며 개발하는 것입니다.
  
  이렇게 함으로써 버그가 적고 간결한 소스코드를 작성하게 되고 개발이 끝난 후 테스트를 하는 것보다 테스트 비용이 적고 소스코드 품질은 좋아지게 됩니다.
  
  어느 프로젝트든 처음부터 완벽한 설계는 없기 때문에 당장의 생산성이 떨어지더라도 점진적으로 나아가 질좋은 소스코드, 재설계 시간 단축, 디버깅 시간 단축, 테스트문서 대체가능, 추가 개발에 용이함 등의 장점을 만드는 TDD를 선호한다고 알고 있습니다.

---

- **JWT란? 선택이유**
  
  베이직방식의 인증인가는 사용자 정보를 그대로 클라이언트-서버가 주고받기 떄문에 보안적으로 문제가 있고 세션방식의 인증인가는 보안적으로 문제가 없지만 확장성에 문제가 있기 때문에
  
  확장성도 좋고 보안적으로도 문제가 없는 JWT를 사용했습니다.
  
  JWT방식의 인증인가는 사용자 정보를 토큰에 담아 암호화된 상태로 클라이언트와 주고 받으며 인증인가하는 것입니다.
  
  시크릿 키를 통해 서버에서만 복호화할 수 있습니다. 하지만 시크릿키가 노출되면 손쉽게 해독 가능하기 떄문에 중요하지 않은 사용자 정보를 넣는것이 중요합니다.
  또한 토큰이 탈취되면 사용자인척 할 수 있기 때문에 엑세스토큰과 리프레쉬 토큰 2개를 발급하여 클라이언트와 주고받는 토큰인 엑세스 톹큰은 만료시간을 짧게하고 리프레쉬 토큰은 서버에 보관하면서 만료시간을 길게하여 엑세스 토큰의 짧은 만료시간이 만료되어도 서버에서 리프레쉬 토큰을 확인하여 새로운 엑세스 토큰을 발급하도록 하여 JWT의 보안적인 허점을 극복할수 있습니다.
  
  ---
  
  **동시성 문제 해결, 지금이라면 어떻게 해결할지?**
  
  3가지 방법을 적용해봤습니다.
  자바의 synchronized 키워드, jpa의 낙관적 락 그리고 비관적 락 3가지를 적용해봤습니다.
  먼저 자바의 synchronized 키워드를 메서드에 적용해 하나의 쓰레드만 접근할 수 있도록 했습니다
  하지만 트랜잭션이 커밋되기 전에 다음 요청을 수행해서 문제해결이 불가능 했습니다.
  그 다음 하나의 트랜잭션이 커밋될때 다른 트랜잭션의 작업을 취소하는 낙관적 락을 적용했습니다.
  이것은 동시성 문제를 해결하긴했지만 서비스와 맞지 않았습니다.
  2100원 요청과 근소한 차이로 2300원의 요청이 들어왔을때 2100의 트랜잭션이 커밋될때 2300원의 트랜잭션의 작업이 취소되기 떄문입니다.
  2100원보다 더 높은 가격인 2300원으로 들어온 입찰은 성공되어야 맞지만 실패했습니다.
  따라서 트랜잭션이 커밋된 후 다음 요청을 수행하는 비관적락을 적용해 문제를 해결했습니다.
  
  이는 대규모 서비스에서 성능이슈가 있을 수 있지만 소규모 프로젝트인 저희 서비스에 적합하다고 판단했습니다.
  하지만 이제는 메시지 큐를 적용해서 성능 문제없이 문제를 해결할 것 같습니다.


